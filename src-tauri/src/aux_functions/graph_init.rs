use super::edge_factory::edge_factory;
use super::take_snapshot::total_distance;
use crate::aux_data_structures::neighbor_info::{Neighbor, NeighborInfo};
use crate::aux_functions::conversion_factors::*;
use crate::graph::graph_ds::Graph;
use crate::mesh::device::MeshNode;
use app::protobufs;
use petgraph::graph::NodeIndex;
use std::collections::HashMap;

/*
This file is meant to load a graph from packets and the location info of the nodes (stored
in a hashmap associated with a MeshDevice struct).

To mock a graph, one can call the function load_graph() with a vector of NeighborInfo structs
and location hashmap generated by the mock_generator module.
*/

pub fn load_graph(packets: Vec<NeighborInfo>, mut loc_hashmap: HashMap<u32, MeshNode>) -> Graph {
    // Traverse the array of packets once, adding nodes and edges to our lists
    let mut graph = Graph::new();
    let mut edge_left_endpoints = Vec::<NodeIndex>::new();
    let mut edge_right_endpoints = Vec::<NodeIndex>::new();
    let mut edge_distances = Vec::<f64>::new();
    let mut edge_radio_quality = Vec::<f64>::new();

    for packet in packets {
        // Add node to graph if not initialized
        let name: String = packet.id.to_string();
        if !graph.contains_node(name.clone()) {
            graph.add_node(name.clone());
        }
        let node_index = graph.get_node_idx(name.clone());
        for neighbor in packet.neighbors {
            // Use neighbor info to populate edge lists
            let neighbor_name = neighbor.id.to_string();
            if !graph.contains_node(neighbor_name.clone()) {
                graph.add_node(neighbor_name.clone());
            }
            let nbr_index = graph.get_node_idx(neighbor_name.clone());
            // Get location data for both nodes on edge
            let node_val = loc_hashmap.get_mut(&packet.id).unwrap();
            let node_data = node_val.data.clone();
            let node_position = node_data.position.unwrap();
            let neighbor_val = loc_hashmap.get_mut(&neighbor.id).unwrap();
            let neighbor_data = neighbor_val.data.clone();
            let neighbor_position = neighbor_data.position.unwrap();
            let distance = calculate_converted_distance(
                node_position.latitude_i,
                node_position.longitude_i,
                node_position.altitude,
                neighbor_position.latitude_i,
                neighbor_position.longitude_i,
                neighbor_position.altitude,
            );
            let radio_quality = neighbor.snr;
            edge_left_endpoints.push(node_index);
            edge_right_endpoints.push(nbr_index);
            edge_distances.push(distance);
            edge_radio_quality.push(radio_quality);
        }
    }
    // Create the edges
    let edges = edge_factory(
        edge_left_endpoints,
        edge_right_endpoints,
        edge_distances,
        edge_radio_quality,
        None,
        None,
    );
    // Add the edges to the graph
    for edge in edges {
        graph.add_edge_from_struct(edge);
    }
    graph
}

/*
* Calculates the distance between two points on a sphere
*
* Conversion function:
* Lat/Long: 1e-7 conversion from int to floating point degrees; see mesh.proto
* Altitude: in meters above sea level, no conversion needed
*/
fn calculate_converted_distance(x: i32, y: i32, z: i32, nbr_x: i32, nbr_y: i32, nbr_z: i32) -> f64 {
    let conversion_factor = (10.0 as f64).powi(-7);
    return total_distance(
        x as f64 * LAT_CONVERSION_FACTOR,
        y as f64 * LON_CONVERSION_FACTOR,
        z as f64 * ALT_CONVERSION_FACTOR,
        nbr_x as f64 * LAT_CONVERSION_FACTOR,
        nbr_y as f64 * LON_CONVERSION_FACTOR,
        nbr_z as f64 * ALT_CONVERSION_FACTOR,
    );
}

#[cfg(test)]
mod tests {
    use super::*;

    fn generate_zeroed_position() -> protobufs::Position {
        let position = protobufs::Position {
            latitude_i: 0,
            longitude_i: 0,
            altitude: 0,
            time: 0,
            location_source: 0,
            altitude_source: 0,
            timestamp: 0,
            timestamp_millis_adjust: 0,
            altitude_hae: 0,
            altitude_geoidal_separation: 0,
            pdop: 0,
            hdop: 0,
            vdop: 0,
            gps_accuracy: 0,
            ground_speed: 0,
            ground_track: 0,
            fix_quality: 0,
            fix_type: 0,
            sats_in_view: 0,
            sensor_id: 0,
            next_update: 0,
            seq_number: 0,
        };
        position
    }

    fn generate_test_user() -> protobufs::User {
        let user = protobufs::User {
            id: "test".to_string(),
            long_name: "test".to_string(),
            short_name: "test".to_string(),
            macaddr: Vec::new(),
            hw_model: 0,
            is_licensed: false,
        };
        user
    }

    fn generate_zeroed_device_metrics() -> protobufs::DeviceMetrics {
        let devicemetrics = protobufs::DeviceMetrics {
            battery_level: 0,
            voltage: 0.0,
            channel_utilization: 0.0,
            air_util_tx: 0.0,
        };
        devicemetrics
    }

    #[test]
    fn test_init_graph() {
        let neighbor_1 = Neighbor {
            id: 1,
            timestamp: 0,
            snr: 1.0,
        };
        let neighbor_2 = Neighbor {
            id: 2,
            timestamp: 0,
            snr: 2.0,
        };
        let neighbor_3 = Neighbor {
            id: 3,
            timestamp: 0,
            snr: 3.0,
        };
        let neighbor_4 = Neighbor {
            id: 4,
            timestamp: 0,
            snr: 4.0,
        };
        let neighbor_info_1 = NeighborInfo {
            id: 1,
            timestamp: 0,
            neighbors: vec![neighbor_2.clone(), neighbor_3.clone(), neighbor_4.clone()],
        };
        let neighbor_info_2: NeighborInfo = NeighborInfo {
            id: 2,
            timestamp: 0,
            neighbors: vec![neighbor_1.clone(), neighbor_3.clone(), neighbor_4.clone()],
        };
        let neighbor_info_3: NeighborInfo = NeighborInfo {
            id: 3,
            timestamp: 0,
            neighbors: vec![neighbor_1.clone(), neighbor_2.clone(), neighbor_4.clone()],
        };
        let neighbor_info_4: NeighborInfo = NeighborInfo {
            id: 4,
            timestamp: 0,
            neighbors: vec![neighbor_1.clone(), neighbor_2.clone(), neighbor_3.clone()],
        };
        let meshnode_1: MeshNode = MeshNode {
            device_metrics: vec![],
            environment_metrics: vec![],
            data: protobufs::NodeInfo {
                num: 1,
                user: Some(generate_test_user()),
                position: Some(generate_zeroed_position()),
                snr: 0.0,
                last_heard: 0,
                device_metrics: Some(generate_zeroed_device_metrics()),
            },
        };
        let meshnode_2: MeshNode = MeshNode {
            device_metrics: vec![],
            environment_metrics: vec![],
            data: protobufs::NodeInfo {
                num: 2,
                user: Some(generate_test_user()),
                position: Some(generate_zeroed_position()),
                snr: 0.0,
                last_heard: 0,
                device_metrics: Some(generate_zeroed_device_metrics()),
            },
        };
        let meshnode_3 = MeshNode {
            device_metrics: vec![],
            environment_metrics: vec![],
            data: protobufs::NodeInfo {
                num: 3,
                user: Some(generate_test_user()),
                position: Some(generate_zeroed_position()),
                snr: 0.0,
                last_heard: 0,
                device_metrics: Some(generate_zeroed_device_metrics()),
            },
        };
        let meshnode_4 = MeshNode {
            device_metrics: vec![],
            environment_metrics: vec![],
            data: protobufs::NodeInfo {
                num: 4,
                user: Some(generate_test_user()),
                position: Some(generate_zeroed_position()),
                snr: 0.0,
                last_heard: 0,
                device_metrics: Some(generate_zeroed_device_metrics()),
            },
        };
        let mut loc_hashmap: HashMap<u32, MeshNode> = HashMap::new();
        loc_hashmap.insert(1, meshnode_1);
        loc_hashmap.insert(2, meshnode_2);
        loc_hashmap.insert(3, meshnode_3);
        loc_hashmap.insert(4, meshnode_4);
        let graph = load_graph(
            vec![
                neighbor_info_1,
                neighbor_info_2,
                neighbor_info_3,
                neighbor_info_4,
            ],
            loc_hashmap,
        );
        // Check that the graph has the correct number of nodes
        assert_eq!(graph.get_order(), 4);
        // Check that the graph has the correct number of edges
        assert_eq!(graph.get_size(), 12);
    }
}
